Revision Cache Format
=====================

The revision cache is an on-disk format which allows for certain graph
reachability operations to be answered quickly.

A revision cache contains;

  - A list of 'end' objects (ie, 'interesting' object ID)

  - A list of 'start' objects, which may be empty (ie, 'uninteresting'
    object IDs)

  - A list of objects which are referred to by any 'end' object, but
    not by crossing 'start' objects, including:

    * position when sorted in --topo-order

    * object type

    * uncompressed size

    * object ID

  - A hash table from an (abbreviated) object ID to a position into
    the above list

  - For each 'end' object, a bit sequence indicating which of the
    objects in the object list are reachable from that 'end' object.
    These bitmaps are RLE-compressed, so don't take much on-disk
    space.


Start Objects and End Objects
-----------------------------

The 'end' object, and 'start' objects are the identifying key of the
revision cache.  Revision caches for multiple 'end' objects can re-use
the same object list, conserving space and adding flexibility to the
index.

The 'start' objects must be reachable from the 'end' objects, and none
of the 'start' objects may be reachable from other 'start' objects.


Topological contents list
-------------------------

This list has fixed-length records, so the topological position into
the list does not need to be stored in each record as it is implicit
from the offset.

The 'type' and 'size' fields are kept as potentially useful pieces of
information that will assist various operations.


Included object hash table
--------------------------

This index is used to quickly determine if an object exists in the
index without scanning the entire topological list.

Entries in the object hash table can be shortened, eg to 3 or 4 bytes;
basically they just need to be long enough to avoid collisions within
the objects which exist in the list.  Any match must be confirmed by
checking the full SHA1 in the topological list.


Efficiency of Operations
------------------------
In this section, the key functions that this index is designed to
answer are explored.  For each, their efficiency is considered in
terms of what operations must be carried out to calculate the answer.


Determining Cache Suitability
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

A revision cache is suitable whenever the walker encounters the single
object which is any of the 'end' objects of the revision cache, and
none of the 'uninteresting' revisions to the walker are in the
revision cache.

The function is:

  rev_cache.suitable( object, uninteresting[] )

In practice, this is likely to be implemented by making in-core cache
entries for objects with revision caches prior to walking.  It then
checks for all revision caches that have that 'end' object, and uses
the largest one which is suitable, creating in-core cache stub entries
and marking all those objects as 'seen' and pushing the 'start'
objects of the revision cache used onto the stack of nodes yet to
walk.


Determining Object Reachability
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

This is a specific use case of the cache where a particular
reachability question is being asked.

The relevant functions are:

  reachable?( from, item )
  rev_cache.reachable?( from, item )

Meaning "is <item> reachable from <from>?", possibly within the
context of a particular revision cache.

This question is an implicit part of the act of walking the object
graph.  When the walker encounters an in-core cache entry which is
marked as having a revision cache, it can answer the question by
looking up the entry in the hash table.

If there are 'start' objects in the revision cache used, the function
must recurse, potentially checking all the different caches that
exist.


Returning Object Lists
~~~~~~~~~~~~~~~~~~~~~~

The functions for this are (expressed in a form intended to resemble
the current revision walker API):

  rev_cache_init()
  rev_cache_add( interesting?, oid )

Then, to create an index on disk:

  rev_cache_create( )

To lookup and iterate over:

  rev_cache_enumerate( type?[], ordered? )
  rev_cache_fetch() : (oid, length, type, new)

The 'rev_cache_enumerate()' allows a couple of flags to be set that
will affect whether or not it works without a new cache being built.

The type?[] bit array allows objects of particular types to be
excluded, such as to return only commit objects.

The ordered? flag means that the correct topological order must be
honoured.

If multiple revisions are passed to rev_cache_add(), then the
operation may become relatively expensive, depending upon the number
of refs and how many objects are in each object list.  However, in the
case that all of the objects passed can be found as 'end' refs in the
same revision cache, the operation will still be very efficient.

If revisions are passed which are marked as not interesting, then the
revision caches employed must not contain those objects.

The 'rev_cache_fetch()' iterator returns entries from the topological
list.


Resolving deltas
~~~~~~~~~~~~~~~~

The above sections describe how object lists are cached.  This is
currently the most expensive part of upload-pack.

However, as well as returning the list of objects for a given fetch,
we need to know whether the delta bases in the pack files we retrieve
the objects from are reachable.  This adds potentially many more
reachability operations to perform.  So, pack-objects will need to
load stub entries for all objects in the pack into the in-core cache.

Another approach is that pack objects are created with deltas arranged
such that they always point in the "same direction" relative to their
topological appearance in a corresponding revision cache.  This will
allow direct copying of compressed revisions from the packfile to the
wire with no intermediate pack generation phase.
