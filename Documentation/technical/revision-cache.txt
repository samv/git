Revision Cache Format
=====================

The revision cache is an on-disk format which allows for certain graph
reachability operations to be answered quickly.

A revision cache contains;

  - An 'end' object (ie, 'interesting' object ID)

  - A list of objects which are referred to by the 'end' object

    * position when sorted in --topo-order

    * object type

    * uncompressed size

    * object ID

  - A hash table from an (abbreviated) object ID to a position into
    the above list


End Object
----------

The 'end' object is the identifying key of the revision cache.


Topological contents list
-------------------------

This list has fixed-length records, so the topological position into
the list does not need to be stored in each record as it is implicit
from the offset.

The 'type' and 'size' fields are kept as potentially useful pieces of
information that will assist various operations.


Included object hash table
--------------------------

This index is used to quickly determine if an object exists in the
index without scanning the entire topological list.

Entries in the object hash table can be shortened, eg to 3 or 4 bytes;
basically they just need to be long enough to avoid collisions within
the objects which exist in the list.  Any match must be confirmed by
checking the full SHA1 in the topological list.


Efficiency of Operations
------------------------
In this section, the key functions that this index is designed to
answer are explored.  For each, their efficiency is considered in
terms of what operations must be carried out to calculate the answer.


Determining Cache Suitability
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

A revision cache is suitable whenever the walker encounters the single
object which is the 'end' object of the revision cache.

The function is:

  rev_cache.suitable( object )

In practice, this is likely to be implemented by making in-core cache
entries for objects with revision caches prior to walking.


Determining Object Reachability
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

This is a specific use case of the cache where a particular
reachability question is being asked.

The relevant functions are:

  reachable?( from, item )
  rev_cache.reachable?( from, item )

Meaning "is <item> reachable from <from>?", possibly within the
context of a particular revision cache.

This question is an implicit part of the act of walking the object
graph.  When the walker encounters an in-core cache entry which is
marked as having a revision cache, it can answer the question by
looking up the entry in the hash table.


Returning Object Lists
~~~~~~~~~~~~~~~~~~~~~~

The functions for this are (expressed in a form intended to resemble
the current revision walker API):

  rev_cache_init()
  rev_cache_add( interesting?, oid )

Then, to create an index on disk:

  rev_cache_create( )

To lookup and iterate over:

  rev_cache_enumerate( type?[], ordered? )
  rev_cache_fetch() : (oid, length, type, new)

The 'rev_cache_enumerate()' allows a couple of flags to be set that
will affect whether or not it works without a new cache being built.

The type?[] bit array allows objects of particular types to be
excluded, such as to return only commit objects.

The ordered? flag means that the correct topological order must be
honoured.

If multiple revisions are passed to rev_cache_add(), then the
operation may become relatively expensive, depending upon the number
of refs and how many objects are in each object list.

The 'rev_cache_fetch()' iterator returns entries from the topological
list.


Resolving deltas
~~~~~~~~~~~~~~~~

The above sections describe how object lists are cached.  This is
currently the most expensive part of upload-pack.

However, as well as returning the list of objects for a given fetch,
we need to know whether the delta bases in the pack files we retrieve
the objects from are reachable.  This adds potentially many more
reachability operations to perform.  So, pack-objects will need to
load stub entries for all objects in the pack into the in-core cache.

Another approach is that pack objects are created with deltas arranged
such that they always point in the "same direction" relative to their
topological appearance in a corresponding revision cache.  This will
allow direct copying of compressed revisions from the packfile to the
wire with no intermediate pack generation phase.
